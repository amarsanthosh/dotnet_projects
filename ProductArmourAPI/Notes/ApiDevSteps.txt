
----------BookMart api-------------------

1. Created Models -> added the properties
2. Created new database 
3. Installed the extensions from nuget gallery (M.efc.Toold,design,sqlserver)
4. data -> applicationdbcontext.cs   -> inherit the dbcontext
5. public ApplicationDbContext(DbContextOptions dbContextOptions) : base(dbContextOptions){}
6. Dbset<Tablename> name {g;s;}
7. need to plug in Program.cs => builder.Services.AddDbContext<ApplicationDbContext>(Options =>{    Options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));});
8. Add connectionstrings in app.settings.json
9. Now do the Migrations (after altering anything in the database structure do the migrations) 
10. Now deal with the   - Interface - repository -  controller
11. add the scope of interface in program.cs
12. dont forget to inherit the contollerbase
13. To add swagger api -> 1st install swashbuckle.aspnet from nuget, then in program.cs add builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen();  , then inside the if (app.useSwagger,UI)
14. Now implement the CRUD operations on our dbs
15. For POST we need to create a CreateDto
16. And a mapper for that...
17. In repository layer don't forget to save the changes done to the database. 

|||||| Basic Api to perform CRUD operations is Developed |||||||


------------Authetication and Authorization-----------------

step 1 : set up ASP.NET core Identity
-------------------------------------- 
1. install identity extensions from nuget -> it comes with identityUser,SigninManager,UserManager class {identity - core , efc | authentication.jwtbearer}
2. create a AppUser model
3. make sure to tell the applictiondbcontext that we are using identity. {IdentityDbContext<AppUser>}
4. AddIdentity services in Program.cs
builder.Services.AddIdentity<AppUser,IdentityRole>(Options =>
{
    Options.Password.RequireDigit = true;
    Options.Password.RequiredLength = 8;
    Options.Password.RequireLowercase = true;
    Options.Password.RequireUppercase = true;
}).AddEntityFrameworkStores<ApplicationDbContext>();

Why?
This wires up everything : UserManager to manage users , SignInManager to handle login , Tells Identity to store everything in the AppDbContext

step 2 : Add JWT Authentication {Json web token}
------------------------------------------------

5. install extension -> Microsoft.AspNetCore.Authentication.JwtBearer
6. Add JWT settings in appsettings  
"JWT" : {
    "Issuser" : "http://localhost:5234",
    "Audience" : "http://localhost:5234",
    "SingingKey" : "LovemelikeyoudolalaLovemelikeyoudokissmelikeyoudolalakissmelikeyoudo" ,
    "DurationInMinutes" : 60
  }
7. AddAuthentication and addjwtbearer service in program.cs 
var jwtSettings = builder.Configuration.GetSection("Jwt"); 
builder.Services.AddAuthentication(Options =>
{
    Options.DefaultAuthenticateScheme =
    Options.DefaultChallengeScheme =
    Options.DefaultForbidScheme =
    Options.DefaultScheme =
    Options.DefaultSignInScheme =
    Options.DefaultSignOutScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(Options =>
{
    Options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateIssuerSigningKey = true,
        ValidateLifetime = true,
        ValidIssuer = jwtSettings["Issuer"],
        ValidAudience = jwtSettings["Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(
            System.Text.Encoding.UTF8.GetBytes(jwtSettings["Signingkey"]!)
        )
    }; 
} ); 

8. Create the AccountController.cs
9. Now create a RegisterDto under Account folder in DTOs
public class RegisterDto
    {
        [Required]
        public string? Username { get; set; }
        [Required]
        [EmailAddress]
        public string? Email { get; set; }
        [Required]
        public string? Password { get; set; }
        
    }

Now we need to assign any one to the user {user, admin}

10. In Applicationdbcontext override the OnModelCreating() method
protected override void OnModelCreating(ModelBuilder builder)
        {
            base.OnModelCreating(builder);
            List<IdentityRole> roles = new List<IdentityRole>
            {
                new IdentityRole{
                    Id = "1",
                    Name = "Admin",
                    NormalizedName = "ADMIN"
                },
                new IdentityRole{
                    Id = "2",
                    Name = "User",
                    NormalizedName = "USER"
                }
            };
            builder.Entity<IdentityRole>().HasData(roles);
        }

11. Now complete the AccountController {register user endpoint}
 [HttpPost("register")]
        public async Task<IActionResult> Register([FromBody] RegisterDto registerDto)
        {
            try
            {
                if (!ModelState.IsValid) return BadRequest(ModelState);
                var appUser = new AppUser
                {
                    UserName = registerDto.Username,
                    Email = registerDto.Email
                };
                var createUser = await _userManager.CreateAsync(appUser, registerDto.Password!);
                if (createUser.Succeeded)
                {
                    var roleResult = await _userManager.AddToRoleAsync(appUser, "User");
                    if (roleResult.Succeeded)
                    {
                        return Ok("User Created");
                    }
                    else
                    {
                        return StatusCode(500, roleResult.Errors);
                    }
                }
                else
                {
                    return StatusCode(500, createUser.Errors);
                }
            }
            catch (Exception e)
            {
                return StatusCode(500, e);
            }
        }
    }

12. do the database migrations and update.

Now for login we need to generate a JWT token :
----------------------------------------------

13. create a new Service folder under api. 
14. create a ITokenService in Interface.
            string createToken(AppUser user);
15. create a TokenService in Service folder
	üßæ Step 1: Claims ‚Äì What information do you want in the token?
	üîë Step 2: Signing Credentials ‚Äì How do you lock the token?
	üìú Step 3: Define the Token‚Äôs Contents (Descriptor)
	üè≠ Step 4: Create the Token
	üßæ Step 5: Return the Token as a String

    public class TokenService : ITokenService
    {
        private readonly IConfiguration _config;
        private readonly SymmetricSecurityKey _key;
        public TokenService(IConfiguration config)
        {
            _config = config;
            _key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["JWT:SigningKey"]!));
        }
        public string createToken(AppUser user)
        {
            var claims = new List<Claim>{
                new Claim(JwtRegisteredClaimNames.Email, user.Email!),
                new Claim(JwtRegisteredClaimNames.GivenName, user.UserName)
            };
            var creds = new SigningCredentials(_key, SecurityAlgorithms.HmacSha512Signature);//‚ÄúUse this secret key and this algorithm to lock (sign) the token.‚Äù

            //Think of this as filling out a passport form: Who are you, when does it expire, who‚Äôs issuing it, etc.
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                Expires = DateTime.Now.AddDays(7),
                SigningCredentials = creds,
                Issuer = _config["JWT:Issuer"],
                Audience = _config["JWT:Audience"]
            };

            //Generate the token
            var tokenHandler = new JwtSecurityTokenHandler();
            var token = tokenHandler.CreateToken(tokenDescriptor);

            //writeToken -> converts the token as a String
            return tokenHandler.WriteToken(token);
        }
    }

16. register the TokenService in program.cs
	builder.Services.AddScoped<ITokenService, TokenService>();

17. create NewUserDto for returning purpose {username, Email, Token}
18. Inject the ITokenService in Account Controller and while return newuserdto on succeed
	          return Ok(
                            new NewUserDto
                            {
                                Username = appUser.UserName,
                                Email = appUser.Email,
                                Token = _tokenservice.createToken(appUser)
                            }
                        );


Now complete the AccountController {login endpoint}
---------------------------------------------------
19. Create a Login Dto. 
    public class LoginDto
    {
        [Required]
        public string? Name { get; set; }
        [Required]
        public string? Password { get; set; }
    }

20. Now implement the Login endpoint
	[HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginDto loginDto)
        {
            if (!ModelState.IsValid) return BadRequest(ModelState);

            var user = await _userManager.Users.FirstOrDefaultAsync(x => x.UserName == loginDto.userName!.ToLower());
            if (user == null) return Unauthorized("Invalid user");
            var result = await _signInManager.CheckPasswordSignInAsync(user, loginDto.Password!, false);
            if (!result.Succeeded) return Unauthorized("Username/password incorrect");
            return Ok(
                new NewUserDto
                {
                    Username = user.UserName,
                    Email = user.Email,
                    Token = _tokenservice.createToken(user)
                }
            );
        }

21. now in program.cs copy paste the code, TO make the swagger compatible for JWT token
builder.Services.AddSwaggerGen(option =>
{
    option.SwaggerDoc("v1", new OpenApiInfo { Title = "Demo API", Version = "v1" });
    option.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        In = ParameterLocation.Header,
        Description = "Please enter a valid token",
        Name = "Authorization",
        Type = SecuritySchemeType.Http,
        BearerFormat = "JWT",
        Scheme = "Bearer"
    });
    option.AddSecurityRequirement(new OpenApiSecurityRequirement
    {
        {
            new OpenApiSecurityScheme
            {
                Reference = new OpenApiReference
                {
                    Type=ReferenceType.SecurityScheme,
                    Id="Bearer"
                }
            },
            new string[]{}
        }
    });
});

22. Protect the endpoints using [Authorize] 
23. Need to seed the admin user , create a seeder folder, AdminSeeder.cs ->
    public class AdminSeeder
    {

        public static async Task SeedRolesAndAdmin(IServiceProvider serviceProvider)
        {
            var userManager = serviceProvider.GetRequiredService<UserManager<AppUser>>();

            //Create admin
            var adminEmail = "admin@gmail.com";
            var adminUser = await userManager.FindByEmailAsync(adminEmail);

            if (adminUser == null)
            {
                var user = new AppUser
                {
                    UserName = "Admin",
                    Email = adminEmail,
                    EmailConfirmed = true
                };
                var result = await userManager.CreateAsync(user, "Admin@123");
                if (result.Succeeded)
                {
                    await userManager.AddToRoleAsync(user, "Admin");
                }
            }
        }       
    }
}

24. Then register this in program.cs
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    await AdminSeeder.SeedRolesAndAdmin(services); 
}

25. add the claims in TokenService , CreateToken method
            var userRoles = await _userManager.GetRolesAsync(user);
            // Add role claims
            foreach (var role in userRoles)
            {
                claims.Add(new Claim(ClaimTypes.Role, role));
            }

________________________________ADMIN USER CREATED AND ROLE BASED ACCESS DONE SUCEESSFULLY_____________________
______________________________________________________________________________________________________________


!!!!!!!!!----- Refresh Token authentication ------!!!!!!!!!!!
-------------------------------------------------------------

For high level workflow , go through the notes.

step 1 : add refreshToken model
	public int Id { get; set; }
        public string Token { get; set; } = string.Empty;
        public DateTime Expires { get; set; }
        public bool IsExpired => DateTime.UtcNow >= Expires;
        public DateTime Created { get; set; }
        public string CreatedByIp { get; set; } = string.Empty;
        public DateTime? Revoked { get; set; }
        public string RevokedByIp { get; set; } = string.Empty;
        public bool IsActive => Revoked == null && !IsExpired; 

step 2: update appuser to include refresh token. 
public List<RefreshToken> RefreshTokens { get; set; } = new();

step 2.1: Add refreshToken Table to database
public DbSet<RefreshToken> RefreshTokens { get; set; }
{after this migrate and update}

step 3: Add generaterefreshToken method in TokenService.
        public RefreshToken GenerateRefreshToken(string ipAddress)
        {
            return new RefreshToken
            {
                Token = Convert.ToBase64String(RandomNumberGenerator.GetBytes(64)),
                Created = DateTime.UtcNow,
                Expires = DateTime.UtcNow.AddDays(7),
                CreatedByIp = ipAddress
            };
        }

step 4: Update the AcccountController to include refreshToken 
After successful login, we need to gen token , and update it to the user and finnaly send/store it in user http cookies

Account Controller :  {Storing the refresh tokens in the list}

	[HttpPost("login")]
        public async Task<IActionResult> Login([FromBody] LoginDto loginDto)
        {
            if (!ModelState.IsValid) return BadRequest(ModelState);

            var user = await _userManager.Users.FirstOrDefaultAsync(x => x.UserName == loginDto.userName!.ToLower());
            if (user == null) return Unauthorized("Invalid user");
            var result = await _signInManager.CheckPasswordSignInAsync(user, loginDto.Password!, false);
            if (!result.Succeeded) return Unauthorized("Username/password incorrect");

            var refreshToken = _tokenservice.GenerateRefreshToken(HttpContext.Connection.RemoteIpAddress!.ToString());
            user.RefreshTokens.Add(refreshToken);
            await _userManager.UpdateAsync(user);

            Response.Cookies.Append("refreshToken", refreshToken.Token, new CookieOptions
            {
                // Secure = true,
                // SameSite = SameSiteMode.Strict,
                HttpOnly = true,
                Expires = refreshToken.Expires
            });

            return Ok(
                new NewUserDto
                {
                    Username = user.UserName,
                    Email = user.Email,
                    Token = await _tokenservice.createToken(user)
                }
            );
        }


        [HttpPost("refresh-token")]
        public async Task<IActionResult> RefreshToken()
        {
            var refreshToken = Request.Cookies["refreshToken"];
            var user = await _userManager.Users.Include(u => u.RefreshTokens)
                                                .SingleOrDefaultAsync(u => u.RefreshTokens.Any(i => i.Token == refreshToken));

            if (user == null)
            {
                return Unauthorized("Invalid Refresh Token");
            }

            var token = user.RefreshTokens.SingleOrDefault(x => x.Token == refreshToken);
            if (!token!.IsActive)
            {
                return Unauthorized("Token is not Active, Expired/Revoked");
            }

            //Now we Rotate the Refresh Token {assigning the new one for extra security}

            var remoteIp = HttpContext.Connection.RemoteIpAddress!.ToString();

            token.Revoked = DateTime.UtcNow;
            token.RevokedByIp = remoteIp;

            var newRefreshToken = _tokenservice.GenerateRefreshToken(remoteIp);
            user.RefreshTokens.Add(newRefreshToken);

            await _userManager.UpdateAsync(user);
            Response.Cookies.Append("refreshToken", newRefreshToken.Token, new CookieOptions
            {
                // Secure = true,
                // SameSite = SameSiteMode.Strict,
                HttpOnly = true,
                Expires = newRefreshToken.Expires
            });

            var newAccessToken = await _tokenservice.createToken(user);

            return Ok(new
            {
                Token = newAccessToken
            });
        }




